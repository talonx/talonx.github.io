---           
layout: post
title: The K8S Networking Implementation in Google Kubernetes Engine
date: 2019-12-08 12:53:35 UTC
updated: 2019-12-08 12:53:35 UTC
comments: false
categories: containers google cloud platform kubernetes networking
---
I was recently digging into some finer points of exposing Kubernetes pods as services and came across <a href="https://www.youtube.com/watch?v=y2bhV81MfKQ&amp;feature=youtu.be" target="_blank">this fantastic talk</a> from Google Cloud Next '17. It's about how Kubernetes networking works on the Google Cloud Platform.</span></span><br /><div style="text-align: justify;"><br /></span></span></div><div style="text-align: justify;">The Kubernetes specification dictates, among other things, the networking requirements for deployment. On the Google Cloud Platform (GCP), K8S is available as the Google Kubernetes Engine (GKE) product. GKE is part of GCP, and uses Google compute instances as the K8S hosts and its virtual network for network traffic.&nbsp;</span></span></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Why is the networking  a big deal? Is the specification not already implemented by the K8S project? It is - however, it needs an underlying set of compute, storage and network resources to function. These resources are usually provided by a cloud provider, or bare metal machines + cloud management software, if you are hosting your own cloud. A cloud provider has to go some extra distance to ensure it meets the K8S spec requirements - because it's providing a virtualized environment, and not all things might work as it does in a non-virtualized one.&nbsp;</span></span><br /><br />The talk is about how Google does it for GKE.</span></span>I've summarized some of the interesting points, leaving out the vanilla Kubernetes details which are easily found in the documentation.</span></span></div><br /></span></span><h2><span style="font-size: large;">Internal Traffic </span></span></h2>Linux network namespaces and virtual interfaces are used as the foundation.&nbsp;</span></span><br /><br /><h4>For two pods to talk to each other</span></span></h4><ul><li>Each VM (K8S cluster host) has a root network namespace (usually eth0)</span></span></li><li>Each pod in that host has its own network namespace, separate from the root</span></span></li><li>For these to talk to each other, we use a pipe between two virtual interfaces, one end of which shows up as (again, usually) vethxx in the VM, and the other end as eth0 in the pod.</span></span></li><li>For two pods to talk to each other, we need a bridge between the vethxxs in the VM, which is (usually) named cbr0. This uses ARP to determine where to route packets.</span></span></li></ul><h4>For two pods to talk to each other <i>across</i> VMs</span> </span></span></h4><ul><li>The network between VMs has to know how to route packets whose src and dest are both pods.</span></span> </span></span></li><li>Each VM has an IP block from which it allocates IPs to pods inside it.</span></span></li><li></span>Once the packet leaves a pod and reaches the bridge, it gets sent out the default route as there is entry on that VM's ARP table for that dest pod IP.</span></span></li><li>&nbsp;</span>At this point, the packet will be dropped by GCP's network as the source IP does not match the VM's IP ("anti-spoof"). To get around this, each VM is setup to be able to forward packets, and disable the anti-spoof mechanism. One static route for each VM is setup on the network to route packets for that VM's pod IP range.</span></span></li></ul><h4>To route pod packets to a pod behind a Service</span></span></h4><ul><li>Once the packet hits the bridge, it's processed by an iptables rule.</span></span></li><li>iptables first chooses a pod for the Service, load balancing between different pods. In iptables proxy mode, it <a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables" target="_blank">chooses backends randomly</a>.</span></span></li><li>iptables then performs a DNAT, changing the destination IP in the packet to that of the dest pod. There is a tool called conntrack that keeps track of the fact that a connection was made to the pod's IP for a packet meant for the Service IP.&nbsp;</span></span></li><li>The packet is routed as usual from src pod to dest pod</span></span></li><li>iptables rewrites the src IP to the Service IP in the response packet before sending it to the pod which made the request</span>&nbsp;</span></span></li><li>iptables is, in general, routing traffic to pods behind a Service.</span>&nbsp;</span></span></li><li>kube-proxy just configures and syncs iptables rules based on changes fetched from the K8S API - the name does not reflect anything about its function. It's a legacy name.</span>&nbsp;</span></span></li><li>DNS runs as a Service, in a pod, in K8S.</span>&nbsp;</span></span></li><ul><li>Special needs - particular Service IP, autoscaled to the cluster size.</span></span></li></ul></ul><h3></span></span></h3><h2><span style="font-size: large;">External Traffic </span></span></h2><h3></span></span></h3><h4>From a pod to the internet</span></span></h4><ul><li>A packet's internal address is rewritten to the external IP of the VM on which the pod is running, so that the internet knows where it came from. The reverse rewrite happens on the way back.</span></span></li><li>Before the traffic goes out of the VM, iptables rewrites the pod's src IP to the VM's internal IP. After this, the same thing happens as in the previous point.</span></span></li></ul><h4>From the internet to a pod using Service type: LoadBalancer</span></span></h4><ul><li>Service type: LoadBalancer creates a network LB in GCP, pointing the GCP forwarding rule to all the VMs in the K8S cluster</span></span></li><li>Google's NLB is a packet forwarder, not a proxy, making it possible to read the original client's IP address from the packet directly. In the L7 ingress LB, this is achieved by the X-Forwarded-For header.</span></span></li><li>LB chooses a VM, which may or may not have the pod (or any pods for that matter) the packet is meant for.</span></span></li><li>iptables on the VM chooses a pod. If it's on a different VM, a DNAT happens like before changing the dest to the pod's IP, instead of the LB's IP.</span></span></li><li>There is a second NAT happening here, changing the src from the client, to this VM's IP. This ensures the original VM on which the packet lands stays in the flow. If this does not happen, and the packet is sent to a different VM from this one, and the response goes back to the NAT layer just before the LB, it will be dropped since the packet was sent to the first VM, and not this one, or the pod where it ended up. This loses the original client IP information though.</span></span></li><li>Once it lands on the other VM, it gets routed to the pod, and the response goes back, with all the reverse NAT happening on the way back.</span></span></li><li>The "imbalance" here that can be caused by the LB knowing only about VMs, and not about pods, is mitigated by re-balancing inside K8S between pods. This balancing is random and apparently is "well-balanced" in practice, but can cause an extra network hop, and the client IP is hidden from the pod.</span></span></li><li>There is an annotation to tune this part.</span></span></li></ul><br /><script src="https://gist.github.com/talonx/d03959515793f9970aa76e79efefd9c9.js"></script> Note that this annotation has been superseded by another property since this talk. <br /><script src="https://gist.github.com/talonx/72fd77618a0c72eb1b84f6a7020e3498.js"></script> Setting this will lead to iptables always choosing a pod on the same node, which also preserves the client IP, but risks imbalance.</span></span><br /><br /><h4>From the internet to a pod using an Ingress LoadBalancer</span></span></h4><ul><li>The NodePort service port forwards to the pod(s) using iptables, like before</span></span></li><li>Source IP of a packet is the internal address of the LB, not the external one. This one is a proxy.</span></span></li><li>The SNAT/DNAT works as in the previous case</span></span></li><li>To avoid the extra network hop, the same OnlyLocal annotation works. </span></span></li></ul>&nbsp;&nbsp;</span></span><br />This talk is more than 2 years old. Since then, there have been newer developments in GKE, including "<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/container-native-load-balancing" target="_blank">container-native load balancing</a>" and in K8S itself, e.g., <a href="https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/" target="_blank">IPVS based load balancing</a>.</span></span><br /><br /></span></span>