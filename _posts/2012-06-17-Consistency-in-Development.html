---           
layout: post
title: Consistency in Development
date: 2009-07-12 08:50:23 UTC
updated: 2009-07-12 08:50:23 UTC
comments: false
categories: automation consistency development software software development
---
<div dir="ltr" style="text-align: left;" trbidi="on">Consistency in Development?<br /><br />Simply put, it means <b><i>following a set of basic guidelines in all development activities, from coding to deployment</i></b>. This does not imply having rigid protocols and processes, because immutable rules don't help development but obstruct it. What it does imply is having simple, tried and tested conventions and some formal processes that people are comfortable with - 'Whatever works best for the team'. The key to getting the most out of consistency is to arrive at these rules by consensus and making sure everyone follows them.<br /><br />It has to start at the very bottom.<br /><br /><b>Coding Standards</b><br />I cannot stress this enough. While there is no such thing as a perfect code convention, there should definitely be an agreed upon convention for a team - where everyone follows the coding standards agreed upon. This is true for any language. Imagine the plight of a developer who has to work on code originally written by someone else, and it takes him hours to figure out what the code does because the coding style followed by the original author is completely different. Junior developers often don't get this. The standards can be chosen democratically by involving every member of the team, freezing the conventions and applying it to everyone's IDE (Most IDEs support code style import/export). Ideally I would trust the developers to follow this, but it can also be enforced at the source control level where style checks can fail a checkin in case somebody messes up.<br /><br /><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Speak the same dialect so that others understand you and vice versa</i>.<br /><br />Maintenance becomes much easier.<br /><br /><b>Architecture</b>Don't run and start to hack away the moment you get the requirements. Stop for a moment - think awhile. Put your thoughts on the whiteboard and discuss with your peers. Run through your design with somebody who knows the big picture. Come up with atleast two or three different solutions to the problem - that way you would know that you have looked at it from various angles and chosen the right one.<br /><br /><b>Application Structure</b>You might have multiple web applications in your project, differing in configuration files, HTMLs, images, css, libraries, server side scripts etc. Storing them in a consistent manner across applications helps keep them organized and makes it easier for developers to find things, especially new ones. You will not be surprised by the completely different disk layout of an application if it follows the same directory structure as all the others. Deep down it also appeals to the organized mindset that most good developers have.<br /><br /><b>Issue Tracking</b><br /><span style="font-weight: normal;">New bugs/features come up every day. Small teams can probably manage these for sometime with sticky notes and paper and pen. Some developers have their own ways of keeping track of their ToDo lists - but without a unified interface, you are not going to scale. You will have chaos - files missed in checkins, people clueless about who is looking into a particular issue, wondering about the status of a critical bug. When your team grows large, you need some kind of tracking system to track milestones and open issues, tasks to do, assign issues to developers and prioritize them. There are lots of good bug tracking systems out there - get one which works best for you.&nbsp;</span><br /><span style="font-weight: normal;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><i>Track issues in the same way across people</i><br /><br /><br /><b>Deployment<br /><span style="font-weight: normal;">Web applications will need to scale somewhere in their lifetimes, especially if they are successful. Think about your initial deployment environment - one webserver and one database server (on the same machine). As time goes by and your app becomes popular, you add servers. And features. New features translate to new application modules and new databases. The simple script you used to upload and deploy your small app is useless now.</span></b><br /><br />At this point, scaling has multiple meanings<br /><pre>    <i>    The ability to handle increasing load and maintain baselevel performance, and<br /><br />        The ability to push code into deployment quickly.</i></pre><br />Both of these are affected by having (or not having) a consistent model.<br /><br />The first point is <i>actual application scaling</i> - the complexity of your infrastructural setup is going to increase hugely as it grows. The second point has to do with <i>how your team scales to increasing demands</i>.<br /><br />They are related. Critical fixes and features might need to be pushed immediately. These demands would reach proportions where you cannot afford to spend time figuring out why Server No 6 in your cluster does not have the latest changes. Automation is the key here. Automation demands formal well defined processes (for making builds, uploading to production servers etc).         Formal deployment processes imply consistency. They do not mean a bureaucracy â€“ just well followed and automated rules about how to deploy a change into production. As your app and infrastructure grows, it becomes more and more important to be able to rollback changes if necessary. This is possible only if you have well defined deployment paths and scripts.<br /><br />Automate wherever possible. Minimize the number of things you have to keep in your head. And in the process, lower your stress levels!<br /><br /><i><b>Note</b>: These thoughts are not entirely mine - these are the culmination of what I feel about consistency after having read the experiences and opinions of many others in blogs, books and articles, coupled with my own experiences in developing products. Also, you might have noted that I have been talking of web application development in some of the sections above, but these apply to any kind of software development.</i><br /><br /><i><br /></i></div>