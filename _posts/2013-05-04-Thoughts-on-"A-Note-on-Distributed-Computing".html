---           
layout: post
title: Thoughts on "A Note on Distributed Computing"
date: 2013-05-04 15:57:22 UTC
updated: 2013-05-04 15:57:22 UTC
comments: false
categories: distributed computing java rmi
---
<b><i>A Note on Distributed Computing by Jim Waldo, Geoff Wyant, Ann Wollrath, and Sam Kendall</i></b> is a widely cited paper. I have been reading and trying to understand it for sometime. It's available here - <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.7628" target="_blank">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.7628</a><br /><br />The title of the paper is innocuous but it's much more than a "note". It analyzes the key differences between local and distributed computing, and explains why attempts to unify their programming models are misguided because of the fundamental differences underlying them.<br /><br />The authors used to be part of the erstwhile Sun Microsystems when they wrote it - it dates from 1994. Later some of them were members of the JINI technology team and also wrote RMI, and if you look at the Java RMI source code,&nbsp; you can see some of their <a href="http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java.rmi/RemoteException.java.html" target="_blank">names</a>.<br /><br />But in 1994 when this paper was written, Java had not emerged yet. There was no J2EE and CORBA was still young.<br /><br />I wish to share my thoughts after reading it, and the realization that the opinions expressed in it influenced the design of Java's RMI.<br /><br /><b>Unification</b><br />Briefly, unification = unification of the local and the distributed programming models. Note that we are talking about distributed object oriented systems here. <br /><br />The unification attempts assume that objects are essentially of a single top level type (like in Java), which might span different address spaces on the same or different machines (like different JVMs on the same or different machines in the case of Java) and they can communicate in the same way irrespective of where they are located. In other words, location (same JVM versus another JVM in another country) is merely an implementation detail that can be abstracted away behind the interfaces used to communicate between two objects without any side effects. <br /><br />Such a (hypothetical) system would have the following characteristics<br /><ul></ul><ol><li>Program functionality is not affected by the location of the object on which an operation has been invoked. Or viewing it from a slightly higher level, there is a single design as to how a system communicates irrespective of whether it's deployed in one address space or in multiple ones.&nbsp;</li><li>Maintenance and upgrades can be done to individual objects without affecting the rest of the system.&nbsp;</li><li>There is no need to handle failure and performance issues in the system design.</li><li>Object interfaces are always the same regardless of the context (i.e. remote or local) </li></ol><ul></ul>The authors contend that all these statements are flawed. I'll not attempt to go into those details - the paper explains them well.<br /><br />The paper then goes onto examine the 4 areas where local and distributed computing differ drastically:<br />&nbsp;&nbsp;&nbsp; Latency<br />&nbsp;&nbsp;&nbsp; Memory Access<br />&nbsp;&nbsp;&nbsp; Partial Failure<br />&nbsp;&nbsp;&nbsp; Concurrency<br /><br />Those  of us who have worked on distributed enterprise and internet software  have come across these. These 4 differences  cannot be papered over to present a 'unified' view of objects which lie  on different machines.<br />&nbsp; <br /><br /><b>Java RMI</b><br />If you look at RMI, you can see its design influenced by the assumption that the above 4 points are invalid.<br /><ul><li>"Remote" objects have to extend the java.rmi.Remote interface<span style="font-family: Arial,Helvetica,sans-serif;">. "Remote" objects - objects that can be invoked from another JVM - are different from local objects.</li><li>Remote (inter-JVM) method calls have to explicitly handle the java.rmi.RemoteException, which is a checked exception, thus highlighting the fact that a distributed call is subject to modes of failure that are non-existent in a local call. In fact, it extends java.io.IOException and the <a href="http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java.rmi/RemoteException.java.html" target="_blank">javadoc</a> is explicit about network issues "<i><span style="font-family: Arial,Helvetica,sans-serif;">is the common superclass for a number of communication-related exceptions that may occur during the execution of a remote method call</i>".</li></ul>Let's look at  #2 again. From the paper:<br /><blockquote class="tr_bq"><i><span style="font-family: Arial,Helvetica,sans-serif;">"As long as the interfaces between objects remain constant, the implementations of those objects can be altered at will".</i></blockquote>Premonition of SOA, anyone? This concept would be familiar today to anybody  who is acquainted with the fundamental principles of  service oriented system design (replace 'object' with 'service'). But since these statements are challenged and refuted later in the paper, the question naturally arises - how come SOA is successful? &nbsp;<br /><br /><span style="font-family: Arial,Helvetica,sans-serif;">SOA assumes that things are independent and distributed services, and any invocation of a service assumes that there are failure modes which exist because of the communication's distributed nature. This builds on the same RMI concept as having to explicitly throw RemoteException when making a remote (distributed) call. This same concept is taken into consideration while writing  any SOA system, which is another way of saying that the authors of the paper were correct. <br /><br />Note: A short and readable summary of Java RMI is to be found in Jim Waldo's book <a href="http://www.amazon.com/Java-Good-Parts-Jim-Waldo/dp/0596803737" target="_blank">Java: The Good Parts</a>.